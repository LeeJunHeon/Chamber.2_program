# ===================================================================================
# OES (Optical Emission Spectrometer) 제어 스크립트
# -----------------------------------------------------------------------------------
# 목적: OES 장비를 초기화하고 스펙트럼 데이터를 측정한 후, 그래프로 시각화합니다.
# 라이브러리:
# - ctypes: C언어로 작성된 외부 DLL 라이브러리 함수를 호출하기 위해 사용
# - numpy: 측정된 배열 데이터를 효율적으로 처리하기 위해 사용
# - matplotlib: 측정 결과를 그래프로 시각화하기 위해 사용
# ===================================================================================

import ctypes
import numpy as np
import matplotlib.pyplot as plt

# --- 1. DLL 준비 과정: 파이썬과 하드웨어 라이브러리 연결 ---

# OES 제조사에서 제공하는 64비트 DLL 파일의 경로를 지정합니다.
dll_path = r"\\VanaM_NAS\VanaM_Sputter\OES\SDKs\DLL\x64\stdcall\SPdbUSBm.dll"

# ctypes를 사용해 DLL 파일을 메모리로 불러와 파이썬 객체로 만듭니다.
# 이제 sp_dll 객체를 통해 DLL 내부의 함수들을 호출할 수 있습니다.
sp_dll = ctypes.CDLL(dll_path)

# --- 2. 함수 시그니처 정의: 파이썬-DLL 간의 통신 규칙 설정 ---
# 이 과정은 파이썬에게 C언어 함수와 '대화'하는 방법을 알려주는 중요한 단계입니다.
# argtypes: 함수에 입력되는 인자(파라미터)의 데이터 타입을 정의합니다.
# restype: 함수가 반환하는 결과값의 데이터 타입을 정의합니다.

# spTestAllChannels는 int16에 대한 포인터(메모리 주소)를 인자로 받아,
# 해당 주소에 sOrderType 값을 직접 기록합니다. (두 번째 값 반환용)
sp_dll.spTestAllChannels.argtypes = [ctypes.POINTER(ctypes.c_int16)]
sp_dll.spTestAllChannels.restype = ctypes.c_int16

sp_dll.spSetupGivenChannel.argtypes = [ctypes.c_int16]
sp_dll.spSetupGivenChannel.restype = ctypes.c_int16

# spGetModel은 채널(int16)과 모델 번호를 기록할 포인터(메모리 주소)를 인자로 받습니다.
sp_dll.spGetModel.argtypes = [ctypes.c_int16, ctypes.POINTER(ctypes.c_int16)]
sp_dll.spGetModel.restype = ctypes.c_int16

sp_dll.spInitGivenChannel.argtypes = [ctypes.c_int16, ctypes.c_int32]
sp_dll.spInitGivenChannel.restype = ctypes.c_int16

# spGetWLTable은 파장 데이터를 채워 넣을 double형 배열의 포인터를 인자로 받습니다.
sp_dll.spGetWLTable.argtypes = [ctypes.POINTER(ctypes.c_double), ctypes.c_int16]
sp_dll.spGetWLTable.restype = ctypes.c_int16

sp_dll.spSetBaseLineCorrection.argtypes = [ctypes.c_int16]
sp_dll.spSetBaseLineCorrection.restype = ctypes.c_int16

sp_dll.spAutoDark.argtypes = [ctypes.c_int16]
sp_dll.spAutoDark.restype = ctypes.c_int16

sp_dll.spGetDevIsNew.argtypes = [ctypes.c_int16]
sp_dll.spGetDevIsNew.restype = ctypes.c_int16

sp_dll.spSetTrgEx.argtypes = [ctypes.c_int16, ctypes.c_int16]
sp_dll.spSetTrgEx.restype = ctypes.c_int16

sp_dll.spSetTEC.argtypes = [ctypes.c_int32, ctypes.c_int16]
sp_dll.spSetTEC.restype = ctypes.c_int16

sp_dll.spSetDblIntEx.argtypes = [ctypes.c_double, ctypes.c_int16]
sp_dll.spSetDblIntEx.restype = ctypes.c_int16

# spReadDataEx는 빛의 세기 데이터를 채워 넣을 int32형 배열의 포인터를 인자로 받습니다.
sp_dll.spReadDataEx.argtypes = [ctypes.POINTER(ctypes.c_int32), ctypes.c_int16]
sp_dll.spReadDataEx.restype = ctypes.c_int16

sp_dll.spCloseGivenChannel.argtypes = [ctypes.c_uint16]
sp_dll.spCloseGivenChannel.restype = ctypes.c_int16

# --- 3. Python 래퍼(Wrapper) 함수: DLL 함수를 더 쉽고 안전하게 사용 ---
# 복잡한 ctypes 관련 코드를 함수 내부에 숨겨, 메인 로직을 간결하게 만듭니다.

def test_all_channels():
    """
    역할: PC에 연결된 모든 OES 장치를 찾아 사용 가능한 첫 번째 채널을 반환합니다.
    입력값: 없음
    반환값: (결과 코드, 채널 번호) 튜플
    """
        
    # 두 번째 리턴값을 저장할 변수
    sOrderType = ctypes.c_int16()  # sOrderType에 기본값 0이 할당됨

    # 첫 번째 리턴값과 두 번째 리턴값을 각각 처리하기 위해 두 번째 값을 byref로 받음
    # ctypes.byref()를 사용해 변수 sOrderType의 '메모리 주소'를 함수로 전달합니다.
    # DLL 함수는 이 주소를 통해 sOrderType 변수의 값을 직접 수정합니다.
    result = sp_dll.spTestAllChannels(ctypes.byref(sOrderType))  # 첫 번째 리턴값은 result에 저장됨
    
    # 두 번째 리턴값은 sOrderType에 저장됨
    return result, sOrderType.value  # sOrderType.value로 값 출력

def setup_channel(sChannel):
    """
    역할: 지정된 채널 번호의 장치를 사용하도록 설정합니다.
    입력값: sChannel (int) - 사용할 채널 번호
    반환값: 결과 코드 (int) - 성공 시 양수, 실패 시 음수
    """
    # 채널 설정
    return sp_dll.spSetupGivenChannel(sChannel)

def get_model(sChannel):
    """
    역할: 설정된 채널의 장비 모델 번호를 가져옵니다.
    입력값: sChannel (int) - 확인할 채널 번호
    반환값: (결과 코드, 모델 번호) 튜플
    """
        
    # 두 번째 리턴값을 저장할 변수
    model = ctypes.c_int16()  # model에 기본값 0이 할당됨

    # [수정] ctypes.byref()를 사용해 변수의 메모리 주소를 전달
    # 채널 번호와 함께, 모델 번호를 저장할 model 변수의 '메모리 주소'를 전달합니다.
    result = sp_dll.spGetModel(sChannel, ctypes.byref(model))  # 첫 번째 리턴값은 result에 저장됨
    # 모델 정보 가져오기
    return result, model.value

def initialize_channel(model, sChannel):
    """
    역할: 확인된 모델 번호를 바탕으로 장비를 최종 초기화합니다.
    입력값: model(int), sChannel(int)
    반환값: 결과 코드 (int)
    """
    # 채널 초기화
    return sp_dll.spInitGivenChannel(model, sChannel)

def get_wavelength_table(channel):
    """
    역할: 장비의 각 픽셀에 해당하는 파장(nm) 값 배열(스펙트럼의 X축)을 가져옵니다.
    입력값: channel (int)
    반환값: (결과 코드, 파장 NumPy 배열) 튜플
    """
    # 1. DLL이 데이터를 채워 넣을 수 있도록 C언어 스타일의 배열(메모리 공간)을 생성합니다.
    # 3680개의 double 배열 초기화 (0으로 채움)
    dWLTable = (ctypes.c_double * 3680)()  # ctypes 배열로 초기화
    for i in range(3680):
        dWLTable[i] = 0.0  # 배열 초기값을 0으로 설정

    # spGetWLTable 호출 (배열과 채널 번호를 전달)
    # 2. 이 메모리 공간의 시작 주소(포인터)를 DLL 함수에 전달합니다.
    result = sp_dll.spGetWLTable(dWLTable, channel)

    # 3. DLL이 채워준 C 배열을 파이썬에서 다루기 쉬운 NumPy 배열로 변환하여 반환합니다.
    # 반환값이 0보다 크면 성공
    if result > 0:
        print("Successfully got the wavelength table.")
        #numpy 배열로 변환하여 반환
        return result, np.array(dWLTable)  # result와 배열을 반환
    else:
        print("Error getting the wavelength table.")
        return result, None
    
def BaseLineCorrection(sChannel):
    """
    역할: 측정값의 기준선(baseline)을 보정하여 배경 노이즈를 줄입니다.
    입력값: sChannel (int)
    반환값: 결과 코드 (int)
    """
    # 베이스 라인 보정
    return sp_dll.spSetBaseLineCorrection(sChannel)

def AutoDark(sChannel):
    """
    역할: 빛이 없는 상태(암전류)의 노이즈를 자동으로 측정하고, 이후 측정값에서 빼도록 설정합니다.
    입력값: sChannel (int)
    반환값: 결과 코드 (int)
    """
    # 자동 다크 보정
    return sp_dll.spAutoDark(sChannel)

def GetDevIsNew(sChannel):
    """
    역할: 장비가 새로운 타입의 모델인지 확인합니다.
    입력값: sChannel (int)
    반환값: 결과 코드 (int)
    """
    # 장치가 새로운지 확인
    return sp_dll.spGetDevIsNew(sChannel)

def SetTrgEx(trigger, sChannel):
    """
    역할: 측정 시작 방식(트리거 모드)을 설정합니다. (예: 11은 내부 소프트웨어 트리거)
    입력값: trigger(int), sChannel(int)
    반환값: 결과 코드 (int)
    """
    # 트리거 설정
    return sp_dll.spSetTrgEx(trigger, sChannel)

def SetTEC(lTEC, sChannel):
    """
    역할: 센서의 온도 유지를 위한 냉각기(TEC)를 켜거나(1) 끕니다(0).
    입력값: lTEC(int), sChannel(int)
    반환값: 결과 코드 (int)
    """
    # TEC 설정
    return sp_dll.spSetTEC(lTEC, sChannel)

def SetDblIntEx(dInt, sChannel):
    """
    역할: 센서가 한 번 빛을 감지하는 시간(적분 시간, ms)을 설정합니다.
    입력값: dInt(double), sChannel(int)
    반환값: 결과 코드 (int)
    """ 
    # 이중 통합 설정
    return sp_dll.spSetDblIntEx(dInt, sChannel)

def ReadDataEx(sChannel):
    """
    역할: 현재 조건에서 빛의 세기(Intensity) 값 배열(스펙트럼의 Y축)을 읽어옵니다.
    입력값: sChannel (int)
    반환값: (결과 코드, 빛의 세기 NumPy 배열) 튜플
    """
    # 빛의 세기 데이터를 저장할 C언어 스타일의 배열(메모리 공간)을 생성합니다.
    temp_intensity = (ctypes.c_int32 * 3680)()  # ctypes 배열로 초기화
    for i in range(3680):
        temp_intensity[i] = 0  # 배열 초기값을 0으로 설정
    # DLL 함수를 호출하여 위 메모리 공간에 데이터를 채웁니다.
    result = sp_dll.spReadDataEx(temp_intensity, sChannel)  # 데이터 읽기

    # 반환값이 0보다 크면 성공
    if result > 0:
        print("Data read successfully.")
        # 결과를 NumPy 배열로 변환하여 반환합니다.
        return result, np.array(temp_intensity)  # result와 배열을 반환
    else:
        print("Error reading data.")
        return result, None

def close_channel(sChannel):
    """
    역할: 사용이 끝난 장비와의 연결을 안전하게 종료합니다.
    입력값: sChannel (int)
    반환값: 결과 코드 (int)
    """
    # 채널 종료
    return sp_dll.spCloseGivenChannel(sChannel)

# 그래프 그리기
def plot_graph(x_data, y_data):
    plt.figure(figsize=(10, 6))  # 그래프 크기 설정
    plt.plot(x_data, y_data, label="Intensity vs Wavelength")  # x, y 데이터로 그래프 그리기
    plt.xlabel('Wavelength (nm)')  # x축 라벨
    plt.ylabel('Intensity')  # y축 라벨
    plt.title('Intensity vs Wavelength')  # 그래프 제목
    plt.grid(True)  # 격자 추가
    plt.legend()  # 범례 추가
    plt.show()  # 그래프 창 띄우기 (VS Code에서 터미널로도 출력)

# --- 4. 메인 실행 블록: 실제 실험 진행 ---

# 실험 조건 설정
integration_time = 60  # 적분 시간 (ms 단위), (이값은 ui를 통해서 입력받도록 변경)
avg = 3                # 평균 낼 측정 횟수

# --- 4.1. 장비 연결 및 초기화 ---
print("1. 장비 연결 및 초기화 시작...")
result_sChannel, sChannel = test_all_channels()
result_setup = setup_channel(sChannel)
result_model, model = get_model(sChannel)
result_init = initialize_channel(model, sChannel)

# --- 4.2. 파장 테이블 로드 및 보정 ---
print("\n2. 파장 테이블 로드 및 보정...")
result_wl_table, wl_table = get_wavelength_table(sChannel)
result_base_line = BaseLineCorrection(sChannel)
result_auto_dark = AutoDark(sChannel)
result_dev_is_new = GetDevIsNew(sChannel)  #생략가능?

# --- 4.3. 측정 조건 설정 ---
print("\n3. 측정 조건 설정...")
result_set_trg = SetTrgEx(11, sChannel)
result_set_tec = SetTEC(1, sChannel)
result_set_dbl_int = SetDblIntEx(integration_time, sChannel)

intensity = np.zeros(3680)  # 누적 데이터 초기화

# --- 4.4. 데이터 측정 및 평균 계산 ---
print(f"\n4. 데이터 측정 시작 (평균 {avg}회)...")
# 모든 측정값을 더하기 위해 0으로 채워진 배열을 생성합니다.
for i in range(avg):
    print(f"   - 측정 {i + 1}/{avg}")
    # avg 횟수만큼 데이터 읽기
    result_read_data, temp_intensity = ReadDataEx(sChannel)  # 데이터 읽기
    # 읽어온 데이터를 누적하여 더합니다.
    intensity = intensity + temp_intensity  # 누적 데이터

# 누적된 값을 횟수로 나누어 평균을 계산합니다. 이는 측정 노이즈를 줄이는 효과가 있습니다.
avg_intensity = intensity / avg  # 평균 계산

# --- 4.5. 마무리 및 연결 종료 ---
print("\n5. 장비 연결 종료...")
result_set_tec = SetTEC(0, sChannel) # 센서 냉각기 끄기
result_close_channel = close_channel(sChannel)  # 채널 종료

# --- 5. 최종 결과 출력 및 시각화 ---
print("\n--- 최종 결과 ---")
print(f"Test All Channels Result: {result_sChannel}, sChannel: {sChannel}")
print(f"Setup Channel Result: {result_setup}")
print(f"Get Model Result: {result_model}, Model: {model}")
print(f"Initialize Channel Result: {result_init}")
print(f"Get Wavelength Table Result: {result_wl_table}")
if wl_table is not None:
    print(f"Wavelength Table: {wl_table[:10]}...")  # 처음 10개 값만 출력
print(f"Base Line Correction Result: {result_base_line}")
print(f"Auto Dark Result: {result_auto_dark}")
print(f"Get Device Is New Result: {result_dev_is_new}")
print(f"Set Trigger Result: {result_set_trg}")
print(f"Set TEC Result: {result_set_tec}")
print(f"Set Double Integration Result: {result_set_dbl_int}")
print(f"Read Data Result: {result_read_data}")
if temp_intensity is not None:
    print(f"Intensity Data: {temp_intensity[:10]}...")  # 처음 10개 값만 출력
print(f"Close Channel Result: {result_close_channel}")

# x축: 10부터 1024개 인덱스
x_data = wl_table[10:1034] 
# y축: avg_intensity의 index 10부터 1024개
y_data = avg_intensity[10:1034]  
# 그래프 그리기 함수 호출
plot_graph(x_data, y_data)


# 출력 결과들 result가 양수면 성공, 음수면 실패인것 같음
# Baseline이 작동하지 않는것으로 보임

# Test All Channels Result: 1, sChannel: 0
# Setup Channel Result: 1
# Get Model Result: 2, Model: 0
# Initialize Channel Result: 1
# Get Wavelength Table Result: 1
# Wavelength Table: [131.43335604 132.31633953 133.1994725  134.08275498 134.96618697
#  135.84976851 136.7334996  137.61738027 138.50141051 139.38559036]...
# Base Line Correction Result: -7
# Auto Dark Result: 1
# Get Device Is New Result: 1
# Set Trigger Result: 1
# Set TEC Result: 1
# Set Double Integration Result: 1
# Read Data Result: 1
# Intensity Data: [1336 1310 1296 1294 1296 1298 1292 1290 1290 1298]...
# Close Channel Result: 1